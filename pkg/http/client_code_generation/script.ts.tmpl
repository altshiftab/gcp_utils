{{- $useEncryption := .Globals.UseEncryption -}}
{{- if $useEncryption }}
import type {JWK} from "jose";
import {compactDecrypt, CompactEncrypt, exportJWK, generateKeyPair, importJWK} from "jose";
{{- end }}
import {fetchEx} from "@altshiftab/utils/http/utils";
{{ define "function" -}}
{{- $noRequestBody := eq .Endpoint.InputType "void" -}}
{{- $isNoBodyMethod := or (eq .Endpoint.Method "GET") (or (eq .Endpoint.Method "HEAD") (eq .Endpoint.Method "DELETE")) -}}
{{- $encryptedInput := eq .Endpoint.ContentType "application/jose" -}}
{{- $encryptedOutput := eq .Endpoint.ExpectedOutputContentType "application/jose" -}}
{{- $authBearer := and .Endpoint.UseAuthentication (eq .Globals.AuthenticationMode "bearer") -}}
export async function {{ .Endpoint.Name }}(
{{- if not $noRequestBody -}}input: {{ .Endpoint.InputType }}{{- if or $authBearer $encryptedInput }}, {{ end }}{{- end -}}
{{- if $encryptedInput -}}serverJwk: JWK{{- if $authBearer }}, {{ end }}{{- end -}}
{{- if $authBearer -}}token: string{{- end -}}
): Promise<{{ .Endpoint.ReturnType }}{{ if .Endpoint.OptionalOutput }} | null{{ end }}> {
    {{- if $authBearer }}
    if (!token)
        throw new Error("Empty token");
    {{ end }}
    {{- if $encryptedOutput }}
    const {publicKey: clientPublicKey, privateKey: clientPrivateKey} = await generateKeyPair(
        "{{ .Globals.CseKeyAlgorithm }}",
        {crv: "{{ .Globals.CseKeyAlgorithmCurve }}"}
    );
    const clientJwk = await exportJWK(clientPublicKey);
    clientJwk.alg = "{{ .Globals.CseKeyAlgorithm }}";
    clientJwk.use = "enc";
    {{- end }}

    const url = new URL("{{ .Endpoint.URL }}"{{ if hasPrefix .Endpoint.URL "/" }}, location.origin{{ end }});
    {{- if and (not $noRequestBody) $isNoBodyMethod }}
    for (const [__k, __v] of Object.entries(input as any)) {
        if (__v === undefined || __v === null)
            continue;
        if (Array.isArray(__v)) {
            for (const __item of __v) {
                url.searchParams.append(__k, String(__item));
            }
        } else if (typeof __v === "object") {
            url.searchParams.append(__k, JSON.stringify(__v));
        } else {
            url.searchParams.append(__k, String(__v));
        }
    }
    {{- end }}

    {{- if and (not $noRequestBody) (not $isNoBodyMethod) }}
        {{- if $encryptedInput }}
    const serverPublicKey = await importJWK(serverJwk);
    const data = await new CompactEncrypt(new TextEncoder().encode(JSON.stringify(input)))
        .setProtectedHeader({
            alg: "{{ .Globals.CseKeyAlgorithm }}",
            enc: "{{ .Globals.CseContentEncryption }}",
            kid: serverJwk.kid,
            cty: "application/json",
        })
        .encrypt(serverPublicKey)
    ;
        {{- else }}
    const data = {{ if eq .Endpoint.ContentType "application/json" }}JSON.stringify(input){{ else }}(input as any){{ end }};
        {{- end }}
    {{- end }}
    const {response, responseText} = await fetchEx(
        url.toString(),
        {
            method: "{{ .Endpoint.Method }}",
            {{- if .Endpoint.UseAuthentication }}
            credentials: "include",
            {{- end }}
            {{- $hasContentType := and (and (not $noRequestBody) (not $isNoBodyMethod)) (ne .Endpoint.ContentType "") -}}
            {{- $hasAuth := $authBearer -}}
            {{- $hasCse := $encryptedOutput -}}
            {{- $hasHeaders := or $hasContentType (or $hasAuth $hasCse) -}}
            {{- if $hasHeaders }}
            headers: {
                {{- if $hasContentType }}
                "Content-Type": "{{ .Endpoint.ContentType }}",
                {{- end }}
                {{- if $hasCse }}
                "{{ .Globals.CseClientPublicJwkHeader }}": JSON.stringify(clientJwk),
                {{- end }}
                {{- if $hasAuth }}
                "Authorization": `Bearer ${token}`,
                {{- end }}
            },
            {{- end }}
            {{- if and (not $noRequestBody) (not $isNoBodyMethod) }}
            body: data,
            {{- end }}
        }
    );

    {{- if eq .Endpoint.ReturnType "void" }}
    return;
    {{- else }}
        {{- if $encryptedOutput }}
    const {plaintext, protectedHeader} = await compactDecrypt(responseText, clientPrivateKey);
    const decryptedText = new TextDecoder().decode(plaintext);
    let output: unknown = decryptedText;

    const protectedHeaderCty = protectedHeader?.cty ?? "";
    if (protectedHeaderCty === "application/json" || protectedHeaderCty.endsWith("+json")) {
        output = JSON.parse(decryptedText);
    }

    return output as {{ .Endpoint.ReturnType }};
        {{- else }}

    const contentType = response.headers.get("Content-Type") || "";

    {{- if .Endpoint.OptionalOutput }}
    if (responseText === "" && contentType === "")
        return null;
    {{- end }}

    if (contentType == "{{ .Endpoint.ExpectedOutputContentType }}") {
            {{- if eq .Endpoint.ExpectedOutputContentType "application/json" }}
        return JSON.parse(responseText) as {{ .Endpoint.ReturnType }};
            {{- else }}
        return responseText as unknown as {{ .Endpoint.ReturnType }};
            {{- end }}
    } else {
        throw new Error(`Unexpected content type: ${contentType}`);
    }
        {{- end }}
    {{- end }}
}
{{ end }}

{{- /* Generate for a slice of endpoints if provided */ -}}
{{- if .Endpoints }}
    {{- range .Endpoints }}
{{ template "function" (dict "Endpoint" . "Globals" $.Globals) }}
    {{- end }}
{{- else }}
    {{/* Otherwise treat the root as a single FunctionSpec */}}
{{ template "function" (dict "Endpoint" . "Globals" $.Globals) }}
{{- end }}
